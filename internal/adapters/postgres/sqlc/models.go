// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlc

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

type AudioType string

const (
	AudioTypeInput  AudioType = "input"
	AudioTypeOutput AudioType = "output"
)

func (e *AudioType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AudioType(s)
	case string:
		*e = AudioType(s)
	default:
		return fmt.Errorf("unsupported scan type for AudioType: %T", src)
	}
	return nil
}

type NullAudioType struct {
	AudioType AudioType `json:"audio_type"`
	Valid     bool      `json:"valid"` // Valid is true if AudioType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAudioType) Scan(value interface{}) error {
	if value == nil {
		ns.AudioType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AudioType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAudioType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AudioType), nil
}

type CompletionStatus string

const (
	CompletionStatusPending   CompletionStatus = "pending"
	CompletionStatusStreaming CompletionStatus = "streaming"
	CompletionStatusCompleted CompletionStatus = "completed"
	CompletionStatusFailed    CompletionStatus = "failed"
)

func (e *CompletionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CompletionStatus(s)
	case string:
		*e = CompletionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for CompletionStatus: %T", src)
	}
	return nil
}

type NullCompletionStatus struct {
	CompletionStatus CompletionStatus `json:"completion_status"`
	Valid            bool             `json:"valid"` // Valid is true if CompletionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCompletionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.CompletionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CompletionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCompletionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CompletionStatus), nil
}

type ConversationStatus string

const (
	ConversationStatusActive   ConversationStatus = "active"
	ConversationStatusArchived ConversationStatus = "archived"
	ConversationStatusDeleted  ConversationStatus = "deleted"
)

func (e *ConversationStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ConversationStatus(s)
	case string:
		*e = ConversationStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ConversationStatus: %T", src)
	}
	return nil
}

type NullConversationStatus struct {
	ConversationStatus ConversationStatus `json:"conversation_status"`
	Valid              bool               `json:"valid"` // Valid is true if ConversationStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullConversationStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ConversationStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ConversationStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullConversationStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ConversationStatus), nil
}

type MessageRole string

const (
	MessageRoleUser      MessageRole = "user"
	MessageRoleAssistant MessageRole = "assistant"
	MessageRoleSystem    MessageRole = "system"
)

func (e *MessageRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MessageRole(s)
	case string:
		*e = MessageRole(s)
	default:
		return fmt.Errorf("unsupported scan type for MessageRole: %T", src)
	}
	return nil
}

type NullMessageRole struct {
	MessageRole MessageRole `json:"message_role"`
	Valid       bool        `json:"valid"` // Valid is true if MessageRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMessageRole) Scan(value interface{}) error {
	if value == nil {
		ns.MessageRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MessageRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMessageRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MessageRole), nil
}

type OptimizationStatus string

const (
	OptimizationStatusPending   OptimizationStatus = "pending"
	OptimizationStatusRunning   OptimizationStatus = "running"
	OptimizationStatusCompleted OptimizationStatus = "completed"
	OptimizationStatusFailed    OptimizationStatus = "failed"
)

func (e *OptimizationStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = OptimizationStatus(s)
	case string:
		*e = OptimizationStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for OptimizationStatus: %T", src)
	}
	return nil
}

type NullOptimizationStatus struct {
	OptimizationStatus OptimizationStatus `json:"optimization_status"`
	Valid              bool               `json:"valid"` // Valid is true if OptimizationStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOptimizationStatus) Scan(value interface{}) error {
	if value == nil {
		ns.OptimizationStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.OptimizationStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOptimizationStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.OptimizationStatus), nil
}

type SyncStatus string

const (
	SyncStatusPending  SyncStatus = "pending"
	SyncStatusSynced   SyncStatus = "synced"
	SyncStatusConflict SyncStatus = "conflict"
)

func (e *SyncStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SyncStatus(s)
	case string:
		*e = SyncStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SyncStatus: %T", src)
	}
	return nil
}

type NullSyncStatus struct {
	SyncStatus SyncStatus `json:"sync_status"`
	Valid      bool       `json:"valid"` // Valid is true if SyncStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSyncStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SyncStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SyncStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSyncStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SyncStatus), nil
}

type ToolStatus string

const (
	ToolStatusPending   ToolStatus = "pending"
	ToolStatusRunning   ToolStatus = "running"
	ToolStatusSuccess   ToolStatus = "success"
	ToolStatusError     ToolStatus = "error"
	ToolStatusCancelled ToolStatus = "cancelled"
)

func (e *ToolStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ToolStatus(s)
	case string:
		*e = ToolStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ToolStatus: %T", src)
	}
	return nil
}

type NullToolStatus struct {
	ToolStatus ToolStatus `json:"tool_status"`
	Valid      bool       `json:"valid"` // Valid is true if ToolStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullToolStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ToolStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ToolStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullToolStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ToolStatus), nil
}

type AliciaAudio struct {
	ID                string           `json:"id"`
	MessageID         *string          `json:"message_id"`
	AudioType         AudioType        `json:"audio_type"`
	AudioFormat       string           `json:"audio_format"`
	AudioData         []byte           `json:"audio_data"`
	DurationMs        *int32           `json:"duration_ms"`
	Transcription     *string          `json:"transcription"`
	LivekitTrackSid   *string          `json:"livekit_track_sid"`
	TranscriptionMeta []byte           `json:"transcription_meta"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
	DeletedAt         pgtype.Timestamp `json:"deleted_at"`
}

type AliciaConversation struct {
	ID string `json:"id"`
	// User identifier for multi-user support and cross-device sync
	UserID          string             `json:"user_id"`
	Title           string             `json:"title"`
	Status          ConversationStatus `json:"status"`
	LivekitRoomName *string            `json:"livekit_room_name"`
	Preferences     []byte             `json:"preferences"`
	// Last stanza ID received from the client (for reconnection support)
	LastClientStanzaID int32 `json:"last_client_stanza_id"`
	// Last stanza ID sent by the server - negative values (for reconnection support)
	LastServerStanzaID int32            `json:"last_server_stanza_id"`
	CreatedAt          pgtype.Timestamp `json:"created_at"`
	UpdatedAt          pgtype.Timestamp `json:"updated_at"`
	DeletedAt          pgtype.Timestamp `json:"deleted_at"`
	// Current head of the message chain for this conversation, enables message branching
	TipMessageID *string `json:"tip_message_id"`
	// Version of the main system prompt used for this conversation
	SystemPromptVersionID *string `json:"system_prompt_version_id"`
}

type AliciaMcpServer struct {
	ID             string           `json:"id"`
	Name           string           `json:"name"`
	TransportType  string           `json:"transport_type"`
	Command        *string          `json:"command"`
	Args           []string         `json:"args"`
	Env            []byte           `json:"env"`
	Url            *string          `json:"url"`
	ApiKey         *string          `json:"api_key"`
	AutoReconnect  bool             `json:"auto_reconnect"`
	ReconnectDelay int32            `json:"reconnect_delay"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
}

type AliciaMemory struct {
	ID             string           `json:"id"`
	Content        string           `json:"content"`
	Embeddings     *pgvector.Vector `json:"embeddings"`
	EmbeddingsInfo []byte           `json:"embeddings_info"`
	Importance     *float32         `json:"importance"`
	Confidence     *float32         `json:"confidence"`
	UserRating     *int32           `json:"user_rating"`
	CreatedBy      *string          `json:"created_by"`
	SourceType     *string          `json:"source_type"`
	SourceInfo     []byte           `json:"source_info"`
	Tags           []string         `json:"tags"`
	// Whether this memory is pinned for priority access
	Pinned bool `json:"pinned"`
	// Whether this memory is archived and hidden from normal views
	Archived  bool             `json:"archived"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
	DeletedAt pgtype.Timestamp `json:"deleted_at"`
	// Message from which this memory was extracted (for memory_extraction voting)
	SourceMessageID *string `json:"source_message_id"`
}

type AliciaMemoryUsed struct {
	ID                string           `json:"id"`
	ConversationID    string           `json:"conversation_id"`
	MessageID         string           `json:"message_id"`
	MemoryID          string           `json:"memory_id"`
	QueryPrompt       *string          `json:"query_prompt"`
	QueryPromptMeta   []byte           `json:"query_prompt_meta"`
	SimilarityScore   *float32         `json:"similarity_score"`
	Meta              []byte           `json:"meta"`
	PositionInResults *int32           `json:"position_in_results"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
	DeletedAt         pgtype.Timestamp `json:"deleted_at"`
}

type AliciaMessage struct {
	ID             string      `json:"id"`
	ConversationID string      `json:"conversation_id"`
	SequenceNumber int32       `json:"sequence_number"`
	PreviousID     *string     `json:"previous_id"`
	MessageRole    MessageRole `json:"message_role"`
	Contents       string      `json:"contents"`
	// Client-generated ID before server assignment (for offline support)
	LocalID *string `json:"local_id"`
	// Canonical server-assigned ID (for offline support)
	ServerID *string `json:"server_id"`
	// Synchronization state: pending, synced, or conflict
	SyncStatus SyncStatus `json:"sync_status"`
	// Timestamp when the message was last synced with the server
	SyncedAt pgtype.Timestamp `json:"synced_at"`
	// Tracks message completion: pending (created), streaming (being generated), completed (fully generated), failed (error during generation)
	CompletionStatus CompletionStatus `json:"completion_status"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	DeletedAt        pgtype.Timestamp `json:"deleted_at"`
}

type AliciaMetum struct {
	ID        string           `json:"id"`
	Ref       string           `json:"ref"`
	Key       string           `json:"key"`
	Value     *string          `json:"value"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
	DeletedAt pgtype.Timestamp `json:"deleted_at"`
}

type AliciaNote struct {
	ID        string `json:"id"`
	MessageID string `json:"message_id"`
	Content   string `json:"content"`
	// Note category: improvement (suggestion), correction (factual error), context (clarification), general (freeform)
	Category  string           `json:"category"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
	DeletedAt pgtype.Timestamp `json:"deleted_at"`
}

type AliciaReasoningStep struct {
	ID             string           `json:"id"`
	MessageID      string           `json:"message_id"`
	Content        string           `json:"content"`
	SequenceNumber int32            `json:"sequence_number"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	DeletedAt      pgtype.Timestamp `json:"deleted_at"`
}

type AliciaSentence struct {
	ID                     string        `json:"id"`
	MessageID              string        `json:"message_id"`
	SentenceSequenceNumber int32         `json:"sentence_sequence_number"`
	Text                   string        `json:"text"`
	AudioType              NullAudioType `json:"audio_type"`
	AudioFormat            *string       `json:"audio_format"`
	DurationMs             *int32        `json:"duration_ms"`
	AudioBytesize          *int32        `json:"audio_bytesize"`
	AudioData              []byte        `json:"audio_data"`
	Meta                   []byte        `json:"meta"`
	// Tracks sentence completion: pending (created), streaming (being sent), completed (fully sent), failed (error during streaming)
	CompletionStatus CompletionStatus `json:"completion_status"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	DeletedAt        pgtype.Timestamp `json:"deleted_at"`
}

type AliciaSessionStat struct {
	ID             string `json:"id"`
	ConversationID string `json:"conversation_id"`
	// Total number of messages in the session
	MessageCount int32 `json:"message_count"`
	// Total number of tool calls made during the session
	ToolCallCount int32 `json:"tool_call_count"`
	// Total number of unique memories retrieved during the session
	MemoriesUsed int32 `json:"memories_used"`
	// Total duration of the session in seconds
	SessionDurationSeconds int32            `json:"session_duration_seconds"`
	CreatedAt              pgtype.Timestamp `json:"created_at"`
	UpdatedAt              pgtype.Timestamp `json:"updated_at"`
}

type AliciaTool struct {
	ID          string           `json:"id"`
	Name        string           `json:"name"`
	Description string           `json:"description"`
	Schema      json.RawMessage  `json:"schema"`
	Enabled     bool             `json:"enabled"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	DeletedAt   pgtype.Timestamp `json:"deleted_at"`
}

type AliciaToolUse struct {
	ID             string           `json:"id"`
	MessageID      string           `json:"message_id"`
	ToolName       string           `json:"tool_name"`
	ToolArguments  []byte           `json:"tool_arguments"`
	ToolResult     []byte           `json:"tool_result"`
	Status         ToolStatus       `json:"status"`
	ErrorMessage   *string          `json:"error_message"`
	SequenceNumber int32            `json:"sequence_number"`
	CompletedAt    pgtype.Timestamp `json:"completed_at"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	DeletedAt      pgtype.Timestamp `json:"deleted_at"`
}

type AliciaUserConversationCommentary struct {
	ID             string           `json:"id"`
	Content        string           `json:"content"`
	ConversationID string           `json:"conversation_id"`
	MessageID      *string          `json:"message_id"`
	CreatedBy      *string          `json:"created_by"`
	Meta           []byte           `json:"meta"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	DeletedAt      pgtype.Timestamp `json:"deleted_at"`
}

type AliciaVote struct {
	ID             string  `json:"id"`
	ConversationID string  `json:"conversation_id"`
	MessageID      *string `json:"message_id"`
	// Type of entity being voted on: message, tool_use, memory, or reasoning
	TargetType string `json:"target_type"`
	// ID of the target entity being voted on
	TargetID string `json:"target_id"`
	// Vote type: up (positive), down (negative), critical (essential - for memories)
	Vote string `json:"vote"`
	// Optional predefined feedback category for quick structured feedback
	QuickFeedback *string          `json:"quick_feedback"`
	Note          *string          `json:"note"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	DeletedAt     pgtype.Timestamp `json:"deleted_at"`
}

// GEPA training examples derived from user votes or synthetic generation
type GepaTrainingExample struct {
	ID string `json:"id"`
	// GEPA task: tool_selection, memory_selection, or memory_extraction
	TaskType string  `json:"task_type"`
	VoteID   *string `json:"vote_id"`
	// Whether this is a positive (upvote) or negative (downvote) example
	IsPositive bool `json:"is_positive"`
	// GEPA input fields (user_message, context, available_tools, etc.)
	Inputs json.RawMessage `json:"inputs"`
	// GEPA output fields (selected_tool, arguments, memories, etc.)
	Outputs json.RawMessage `json:"outputs"`
	// Vote metadata: quick_feedback, note, vote_value for diagnostic feedback
	VoteMetadata []byte `json:"vote_metadata"`
	// Origin of example: vote (user feedback) or synthetic (generated)
	Source    string           `json:"source"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	DeletedAt pgtype.Timestamp `json:"deleted_at"`
}

// Final optimized prompt programs ready for deployment
type OptimizedProgram struct {
	ID            string           `json:"id"`
	RunID         string           `json:"run_id"`
	SignatureName string           `json:"signature_name"`
	Instructions  string           `json:"instructions"`
	Demos         []byte           `json:"demos"`
	Metadata      []byte           `json:"metadata"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	DeletedAt     pgtype.Timestamp `json:"deleted_at"`
}

// Optimized tool configurations with improved descriptions and schemas
type OptimizedTool struct {
	ID                   string           `json:"id"`
	ToolID               string           `json:"tool_id"`
	OptimizedDescription string           `json:"optimized_description"`
	OptimizedSchema      []byte           `json:"optimized_schema"`
	ResultTemplate       *string          `json:"result_template"`
	Examples             []byte           `json:"examples"`
	Version              int32            `json:"version"`
	Score                *float32         `json:"score"`
	OptimizedAt          pgtype.Timestamp `json:"optimized_at"`
	// Whether this optimized version is currently in use
	Active    bool             `json:"active"`
	DeletedAt pgtype.Timestamp `json:"deleted_at"`
}

// Stores elite solutions from GEPA Pareto optimization, representing non-dominated trade-offs across 7 dimensions
type ParetoArchive struct {
	ID           string `json:"id"`
	RunID        string `json:"run_id"`
	Instructions string `json:"instructions"`
	Demos        []byte `json:"demos"`
	// Per-dimension performance metrics: successRate, quality, efficiency, robustness, generalization, diversity, innovation
	DimensionScores json.RawMessage `json:"dimension_scores"`
	Generation      int32           `json:"generation"`
	// Number of examples this solution solves best, used for coverage-based selection
	Coverage  int32            `json:"coverage"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

// Candidate prompts representing the Pareto frontier during optimization
type PromptCandidate struct {
	ID           string `json:"id"`
	RunID        string `json:"run_id"`
	Instructions string `json:"instructions"`
	Demos        []byte `json:"demos"`
	// Number of examples this candidate covers successfully
	Coverage int32    `json:"coverage"`
	AvgScore *float32 `json:"avg_score"`
	// Generation number in the evolutionary optimization process
	Generation      int32            `json:"generation"`
	ParentID        *string          `json:"parent_id"`
	DimensionScores []byte           `json:"dimension_scores"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	DeletedAt       pgtype.Timestamp `json:"deleted_at"`
}

// Evaluation results for candidate prompts against test examples
type PromptEvaluation struct {
	ID          string  `json:"id"`
	CandidateID string  `json:"candidate_id"`
	ExampleID   string  `json:"example_id"`
	Score       float32 `json:"score"`
	Feedback    *string `json:"feedback"`
	// Execution trace for debugging and analysis
	Trace           []byte           `json:"trace"`
	DimensionScores []byte           `json:"dimension_scores"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	DeletedAt       pgtype.Timestamp `json:"deleted_at"`
}

// GEPA optimization run records tracking prompt optimization sessions
type PromptOptimizationRun struct {
	ID            string             `json:"id"`
	SignatureName string             `json:"signature_name"`
	Status        OptimizationStatus `json:"status"`
	// Optimization configuration including hyperparameters and constraints
	Config           []byte           `json:"config"`
	BestScore        *float32         `json:"best_score"`
	Iterations       int32            `json:"iterations"`
	DimensionWeights []byte           `json:"dimension_weights"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	CompletedAt      pgtype.Timestamp `json:"completed_at"`
	DeletedAt        pgtype.Timestamp `json:"deleted_at"`
}

// Tracks versions of system prompts for GEPA optimization and A/B testing
type SystemPromptVersion struct {
	ID            string `json:"id"`
	VersionNumber *int32 `json:"version_number"`
	// SHA-256 hash of prompt_content for deduplication
	PromptHash    string `json:"prompt_hash"`
	PromptContent string `json:"prompt_content"`
	// Type of prompt: main (base system), tool_selection, memory_selection, memory_extraction
	PromptType  string  `json:"prompt_type"`
	Description *string `json:"description"`
	// Whether this version is currently active for new conversations
	Active        bool             `json:"active"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	ActivatedAt   pgtype.Timestamp `json:"activated_at"`
	DeactivatedAt pgtype.Timestamp `json:"deactivated_at"`
	DeletedAt     pgtype.Timestamp `json:"deleted_at"`
}

// Learned result formatting rules for optimizing tool output presentation
type ToolResultFormatter struct {
	ID        string `json:"id"`
	ToolName  string `json:"tool_name"`
	Template  string `json:"template"`
	MaxLength int32  `json:"max_length"`
	// Character threshold at which to apply summarization
	SummarizeAt   int32            `json:"summarize_at"`
	SummaryPrompt *string          `json:"summary_prompt"`
	KeyFields     []byte           `json:"key_fields"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	DeletedAt     pgtype.Timestamp `json:"deleted_at"`
}

// Tool usage analytics for identifying optimization opportunities
type ToolUsagePattern struct {
	ID       string `json:"id"`
	ToolName string `json:"tool_name"`
	// Pattern describing common user intent for this tool usage
	UserIntentPattern string           `json:"user_intent_pattern"`
	SuccessRate       *float32         `json:"success_rate"`
	AvgResultQuality  *float32         `json:"avg_result_quality"`
	CommonArguments   []byte           `json:"common_arguments"`
	SampleCount       int32            `json:"sample_count"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
	DeletedAt         pgtype.Timestamp `json:"deleted_at"`
}
