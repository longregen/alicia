// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlc

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const createAudio = `-- name: CreateAudio :one

INSERT INTO alicia_audio (
    id, message_id, audio_type, audio_format, audio_data, duration_ms,
    transcription, livekit_track_sid, transcription_meta, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, message_id, audio_type, audio_format, audio_data, duration_ms, transcription, livekit_track_sid, transcription_meta, created_at, updated_at, deleted_at
`

type CreateAudioParams struct {
	ID                string           `json:"id"`
	MessageID         *string          `json:"message_id"`
	AudioType         AudioType        `json:"audio_type"`
	AudioFormat       string           `json:"audio_format"`
	AudioData         []byte           `json:"audio_data"`
	DurationMs        *int32           `json:"duration_ms"`
	Transcription     *string          `json:"transcription"`
	LivekitTrackSid   *string          `json:"livekit_track_sid"`
	TranscriptionMeta []byte           `json:"transcription_meta"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
}

// ==============================================================================
// Audio
// ==============================================================================
func (q *Queries) CreateAudio(ctx context.Context, arg CreateAudioParams) (AliciaAudio, error) {
	row := q.db.QueryRow(ctx, createAudio,
		arg.ID,
		arg.MessageID,
		arg.AudioType,
		arg.AudioFormat,
		arg.AudioData,
		arg.DurationMs,
		arg.Transcription,
		arg.LivekitTrackSid,
		arg.TranscriptionMeta,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i AliciaAudio
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.AudioType,
		&i.AudioFormat,
		&i.AudioData,
		&i.DurationMs,
		&i.Transcription,
		&i.LivekitTrackSid,
		&i.TranscriptionMeta,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createCommentary = `-- name: CreateCommentary :one

INSERT INTO alicia_user_conversation_commentaries (
    id, content, conversation_id, message_id, created_by, meta, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, content, conversation_id, message_id, created_by, meta, created_at, updated_at, deleted_at
`

type CreateCommentaryParams struct {
	ID             string           `json:"id"`
	Content        string           `json:"content"`
	ConversationID string           `json:"conversation_id"`
	MessageID      *string          `json:"message_id"`
	CreatedBy      *string          `json:"created_by"`
	Meta           []byte           `json:"meta"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
}

// ==============================================================================
// Commentaries
// ==============================================================================
func (q *Queries) CreateCommentary(ctx context.Context, arg CreateCommentaryParams) (AliciaUserConversationCommentary, error) {
	row := q.db.QueryRow(ctx, createCommentary,
		arg.ID,
		arg.Content,
		arg.ConversationID,
		arg.MessageID,
		arg.CreatedBy,
		arg.Meta,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i AliciaUserConversationCommentary
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.ConversationID,
		&i.MessageID,
		&i.CreatedBy,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createConversation = `-- name: CreateConversation :one

INSERT INTO alicia_conversations (
    id, title, status, livekit_room_name, preferences, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, user_id, title, status, livekit_room_name, preferences, last_client_stanza_id, last_server_stanza_id, created_at, updated_at, deleted_at, tip_message_id, system_prompt_version_id
`

type CreateConversationParams struct {
	ID              string             `json:"id"`
	Title           string             `json:"title"`
	Status          ConversationStatus `json:"status"`
	LivekitRoomName *string            `json:"livekit_room_name"`
	Preferences     []byte             `json:"preferences"`
	CreatedAt       pgtype.Timestamp   `json:"created_at"`
	UpdatedAt       pgtype.Timestamp   `json:"updated_at"`
}

// ==============================================================================
// Conversations
// ==============================================================================
func (q *Queries) CreateConversation(ctx context.Context, arg CreateConversationParams) (AliciaConversation, error) {
	row := q.db.QueryRow(ctx, createConversation,
		arg.ID,
		arg.Title,
		arg.Status,
		arg.LivekitRoomName,
		arg.Preferences,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i AliciaConversation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Status,
		&i.LivekitRoomName,
		&i.Preferences,
		&i.LastClientStanzaID,
		&i.LastServerStanzaID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TipMessageID,
		&i.SystemPromptVersionID,
	)
	return i, err
}

const createMemory = `-- name: CreateMemory :one

INSERT INTO alicia_memory (
    id, content, embeddings, embeddings_info, importance, confidence,
    user_rating, created_by, source_type, source_info, tags, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, content, embeddings, embeddings_info, importance, confidence, user_rating, created_by, source_type, source_info, tags, pinned, archived, created_at, updated_at, deleted_at, source_message_id
`

type CreateMemoryParams struct {
	ID             string           `json:"id"`
	Content        string           `json:"content"`
	Embeddings     *pgvector.Vector `json:"embeddings"`
	EmbeddingsInfo []byte           `json:"embeddings_info"`
	Importance     *float32         `json:"importance"`
	Confidence     *float32         `json:"confidence"`
	UserRating     *int32           `json:"user_rating"`
	CreatedBy      *string          `json:"created_by"`
	SourceType     *string          `json:"source_type"`
	SourceInfo     []byte           `json:"source_info"`
	Tags           []string         `json:"tags"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
}

// ==============================================================================
// Memory
// ==============================================================================
func (q *Queries) CreateMemory(ctx context.Context, arg CreateMemoryParams) (AliciaMemory, error) {
	row := q.db.QueryRow(ctx, createMemory,
		arg.ID,
		arg.Content,
		arg.Embeddings,
		arg.EmbeddingsInfo,
		arg.Importance,
		arg.Confidence,
		arg.UserRating,
		arg.CreatedBy,
		arg.SourceType,
		arg.SourceInfo,
		arg.Tags,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i AliciaMemory
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.Embeddings,
		&i.EmbeddingsInfo,
		&i.Importance,
		&i.Confidence,
		&i.UserRating,
		&i.CreatedBy,
		&i.SourceType,
		&i.SourceInfo,
		&i.Tags,
		&i.Pinned,
		&i.Archived,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.SourceMessageID,
	)
	return i, err
}

const createMemoryUsage = `-- name: CreateMemoryUsage :one

INSERT INTO alicia_memory_used (
    id, conversation_id, message_id, memory_id, query_prompt, query_prompt_meta,
    similarity_score, meta, position_in_results, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, conversation_id, message_id, memory_id, query_prompt, query_prompt_meta, similarity_score, meta, position_in_results, created_at, updated_at, deleted_at
`

type CreateMemoryUsageParams struct {
	ID                string           `json:"id"`
	ConversationID    string           `json:"conversation_id"`
	MessageID         string           `json:"message_id"`
	MemoryID          string           `json:"memory_id"`
	QueryPrompt       *string          `json:"query_prompt"`
	QueryPromptMeta   []byte           `json:"query_prompt_meta"`
	SimilarityScore   *float32         `json:"similarity_score"`
	Meta              []byte           `json:"meta"`
	PositionInResults *int32           `json:"position_in_results"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
}

// ==============================================================================
// Memory Usage
// ==============================================================================
func (q *Queries) CreateMemoryUsage(ctx context.Context, arg CreateMemoryUsageParams) (AliciaMemoryUsed, error) {
	row := q.db.QueryRow(ctx, createMemoryUsage,
		arg.ID,
		arg.ConversationID,
		arg.MessageID,
		arg.MemoryID,
		arg.QueryPrompt,
		arg.QueryPromptMeta,
		arg.SimilarityScore,
		arg.Meta,
		arg.PositionInResults,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i AliciaMemoryUsed
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.MessageID,
		&i.MemoryID,
		&i.QueryPrompt,
		&i.QueryPromptMeta,
		&i.SimilarityScore,
		&i.Meta,
		&i.PositionInResults,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createMessage = `-- name: CreateMessage :one

INSERT INTO alicia_messages (
    id, conversation_id, sequence_number, previous_id, message_role, contents, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, conversation_id, sequence_number, previous_id, message_role, contents, local_id, server_id, sync_status, synced_at, completion_status, created_at, updated_at, deleted_at
`

type CreateMessageParams struct {
	ID             string           `json:"id"`
	ConversationID string           `json:"conversation_id"`
	SequenceNumber int32            `json:"sequence_number"`
	PreviousID     *string          `json:"previous_id"`
	MessageRole    MessageRole      `json:"message_role"`
	Contents       string           `json:"contents"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
}

// ==============================================================================
// Messages
// ==============================================================================
func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (AliciaMessage, error) {
	row := q.db.QueryRow(ctx, createMessage,
		arg.ID,
		arg.ConversationID,
		arg.SequenceNumber,
		arg.PreviousID,
		arg.MessageRole,
		arg.Contents,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i AliciaMessage
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.SequenceNumber,
		&i.PreviousID,
		&i.MessageRole,
		&i.Contents,
		&i.LocalID,
		&i.ServerID,
		&i.SyncStatus,
		&i.SyncedAt,
		&i.CompletionStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createReasoningStep = `-- name: CreateReasoningStep :one

INSERT INTO alicia_reasoning_steps (
    id, message_id, content, sequence_number, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, message_id, content, sequence_number, created_at, updated_at, deleted_at
`

type CreateReasoningStepParams struct {
	ID             string           `json:"id"`
	MessageID      string           `json:"message_id"`
	Content        string           `json:"content"`
	SequenceNumber int32            `json:"sequence_number"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
}

// ==============================================================================
// Reasoning Steps
// ==============================================================================
func (q *Queries) CreateReasoningStep(ctx context.Context, arg CreateReasoningStepParams) (AliciaReasoningStep, error) {
	row := q.db.QueryRow(ctx, createReasoningStep,
		arg.ID,
		arg.MessageID,
		arg.Content,
		arg.SequenceNumber,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i AliciaReasoningStep
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.Content,
		&i.SequenceNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createSentence = `-- name: CreateSentence :one

INSERT INTO alicia_sentences (
    id, message_id, sentence_sequence_number, text, audio_type, audio_format,
    duration_ms, audio_bytesize, audio_data, meta, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, message_id, sentence_sequence_number, text, audio_type, audio_format, duration_ms, audio_bytesize, audio_data, meta, completion_status, created_at, updated_at, deleted_at
`

type CreateSentenceParams struct {
	ID                     string           `json:"id"`
	MessageID              string           `json:"message_id"`
	SentenceSequenceNumber int32            `json:"sentence_sequence_number"`
	Text                   string           `json:"text"`
	AudioType              NullAudioType    `json:"audio_type"`
	AudioFormat            *string          `json:"audio_format"`
	DurationMs             *int32           `json:"duration_ms"`
	AudioBytesize          *int32           `json:"audio_bytesize"`
	AudioData              []byte           `json:"audio_data"`
	Meta                   []byte           `json:"meta"`
	CreatedAt              pgtype.Timestamp `json:"created_at"`
	UpdatedAt              pgtype.Timestamp `json:"updated_at"`
}

// ==============================================================================
// Sentences
// ==============================================================================
func (q *Queries) CreateSentence(ctx context.Context, arg CreateSentenceParams) (AliciaSentence, error) {
	row := q.db.QueryRow(ctx, createSentence,
		arg.ID,
		arg.MessageID,
		arg.SentenceSequenceNumber,
		arg.Text,
		arg.AudioType,
		arg.AudioFormat,
		arg.DurationMs,
		arg.AudioBytesize,
		arg.AudioData,
		arg.Meta,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i AliciaSentence
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.SentenceSequenceNumber,
		&i.Text,
		&i.AudioType,
		&i.AudioFormat,
		&i.DurationMs,
		&i.AudioBytesize,
		&i.AudioData,
		&i.Meta,
		&i.CompletionStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createTool = `-- name: CreateTool :one

INSERT INTO alicia_tools (
    id, name, description, schema, enabled, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, name, description, schema, enabled, created_at, updated_at, deleted_at
`

type CreateToolParams struct {
	ID          string           `json:"id"`
	Name        string           `json:"name"`
	Description string           `json:"description"`
	Schema      json.RawMessage  `json:"schema"`
	Enabled     bool             `json:"enabled"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
}

// ==============================================================================
// Tools
// ==============================================================================
func (q *Queries) CreateTool(ctx context.Context, arg CreateToolParams) (AliciaTool, error) {
	row := q.db.QueryRow(ctx, createTool,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Schema,
		arg.Enabled,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i AliciaTool
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Schema,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createToolUse = `-- name: CreateToolUse :one

INSERT INTO alicia_tool_uses (
    id, message_id, tool_name, tool_arguments, tool_result, status,
    error_message, sequence_number, completed_at, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, message_id, tool_name, tool_arguments, tool_result, status, error_message, sequence_number, completed_at, created_at, updated_at, deleted_at
`

type CreateToolUseParams struct {
	ID             string           `json:"id"`
	MessageID      string           `json:"message_id"`
	ToolName       string           `json:"tool_name"`
	ToolArguments  []byte           `json:"tool_arguments"`
	ToolResult     []byte           `json:"tool_result"`
	Status         ToolStatus       `json:"status"`
	ErrorMessage   *string          `json:"error_message"`
	SequenceNumber int32            `json:"sequence_number"`
	CompletedAt    pgtype.Timestamp `json:"completed_at"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
}

// ==============================================================================
// Tool Uses
// ==============================================================================
func (q *Queries) CreateToolUse(ctx context.Context, arg CreateToolUseParams) (AliciaToolUse, error) {
	row := q.db.QueryRow(ctx, createToolUse,
		arg.ID,
		arg.MessageID,
		arg.ToolName,
		arg.ToolArguments,
		arg.ToolResult,
		arg.Status,
		arg.ErrorMessage,
		arg.SequenceNumber,
		arg.CompletedAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i AliciaToolUse
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.ToolName,
		&i.ToolArguments,
		&i.ToolResult,
		&i.Status,
		&i.ErrorMessage,
		&i.SequenceNumber,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteAllMetaByRef = `-- name: DeleteAllMetaByRef :exec
UPDATE alicia_meta
SET deleted_at = $2
WHERE ref = $1 AND deleted_at IS NULL
`

type DeleteAllMetaByRefParams struct {
	Ref       string           `json:"ref"`
	DeletedAt pgtype.Timestamp `json:"deleted_at"`
}

func (q *Queries) DeleteAllMetaByRef(ctx context.Context, arg DeleteAllMetaByRefParams) error {
	_, err := q.db.Exec(ctx, deleteAllMetaByRef, arg.Ref, arg.DeletedAt)
	return err
}

const deleteAudio = `-- name: DeleteAudio :exec
UPDATE alicia_audio
SET deleted_at = $2
WHERE id = $1 AND deleted_at IS NULL
`

type DeleteAudioParams struct {
	ID        string           `json:"id"`
	DeletedAt pgtype.Timestamp `json:"deleted_at"`
}

func (q *Queries) DeleteAudio(ctx context.Context, arg DeleteAudioParams) error {
	_, err := q.db.Exec(ctx, deleteAudio, arg.ID, arg.DeletedAt)
	return err
}

const deleteConversation = `-- name: DeleteConversation :exec
UPDATE alicia_conversations
SET deleted_at = $2
WHERE id = $1 AND deleted_at IS NULL
`

type DeleteConversationParams struct {
	ID        string           `json:"id"`
	DeletedAt pgtype.Timestamp `json:"deleted_at"`
}

func (q *Queries) DeleteConversation(ctx context.Context, arg DeleteConversationParams) error {
	_, err := q.db.Exec(ctx, deleteConversation, arg.ID, arg.DeletedAt)
	return err
}

const deleteMemory = `-- name: DeleteMemory :exec
UPDATE alicia_memory
SET deleted_at = $2
WHERE id = $1 AND deleted_at IS NULL
`

type DeleteMemoryParams struct {
	ID        string           `json:"id"`
	DeletedAt pgtype.Timestamp `json:"deleted_at"`
}

func (q *Queries) DeleteMemory(ctx context.Context, arg DeleteMemoryParams) error {
	_, err := q.db.Exec(ctx, deleteMemory, arg.ID, arg.DeletedAt)
	return err
}

const deleteMessage = `-- name: DeleteMessage :exec
UPDATE alicia_messages
SET deleted_at = $2
WHERE id = $1 AND deleted_at IS NULL
`

type DeleteMessageParams struct {
	ID        string           `json:"id"`
	DeletedAt pgtype.Timestamp `json:"deleted_at"`
}

func (q *Queries) DeleteMessage(ctx context.Context, arg DeleteMessageParams) error {
	_, err := q.db.Exec(ctx, deleteMessage, arg.ID, arg.DeletedAt)
	return err
}

const deleteMeta = `-- name: DeleteMeta :exec
UPDATE alicia_meta
SET deleted_at = $2
WHERE ref = $1 AND key = $3 AND deleted_at IS NULL
`

type DeleteMetaParams struct {
	Ref       string           `json:"ref"`
	DeletedAt pgtype.Timestamp `json:"deleted_at"`
	Key       string           `json:"key"`
}

func (q *Queries) DeleteMeta(ctx context.Context, arg DeleteMetaParams) error {
	_, err := q.db.Exec(ctx, deleteMeta, arg.Ref, arg.DeletedAt, arg.Key)
	return err
}

const deleteSentence = `-- name: DeleteSentence :exec
UPDATE alicia_sentences
SET deleted_at = $2
WHERE id = $1 AND deleted_at IS NULL
`

type DeleteSentenceParams struct {
	ID        string           `json:"id"`
	DeletedAt pgtype.Timestamp `json:"deleted_at"`
}

func (q *Queries) DeleteSentence(ctx context.Context, arg DeleteSentenceParams) error {
	_, err := q.db.Exec(ctx, deleteSentence, arg.ID, arg.DeletedAt)
	return err
}

const deleteTool = `-- name: DeleteTool :exec
UPDATE alicia_tools
SET deleted_at = $2
WHERE id = $1 AND deleted_at IS NULL
`

type DeleteToolParams struct {
	ID        string           `json:"id"`
	DeletedAt pgtype.Timestamp `json:"deleted_at"`
}

func (q *Queries) DeleteTool(ctx context.Context, arg DeleteToolParams) error {
	_, err := q.db.Exec(ctx, deleteTool, arg.ID, arg.DeletedAt)
	return err
}

const getAllMetaByRef = `-- name: GetAllMetaByRef :many
SELECT id, ref, key, value, created_at, updated_at, deleted_at FROM alicia_meta
WHERE ref = $1 AND deleted_at IS NULL
ORDER BY key ASC
`

func (q *Queries) GetAllMetaByRef(ctx context.Context, ref string) ([]AliciaMetum, error) {
	rows, err := q.db.Query(ctx, getAllMetaByRef, ref)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AliciaMetum{}
	for rows.Next() {
		var i AliciaMetum
		if err := rows.Scan(
			&i.ID,
			&i.Ref,
			&i.Key,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAudioByID = `-- name: GetAudioByID :one
SELECT id, message_id, audio_type, audio_format, audio_data, duration_ms, transcription, livekit_track_sid, transcription_meta, created_at, updated_at, deleted_at FROM alicia_audio
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetAudioByID(ctx context.Context, id string) (AliciaAudio, error) {
	row := q.db.QueryRow(ctx, getAudioByID, id)
	var i AliciaAudio
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.AudioType,
		&i.AudioFormat,
		&i.AudioData,
		&i.DurationMs,
		&i.Transcription,
		&i.LivekitTrackSid,
		&i.TranscriptionMeta,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAudioByLiveKitTrack = `-- name: GetAudioByLiveKitTrack :one
SELECT id, message_id, audio_type, audio_format, audio_data, duration_ms, transcription, livekit_track_sid, transcription_meta, created_at, updated_at, deleted_at FROM alicia_audio
WHERE livekit_track_sid = $1 AND deleted_at IS NULL
`

func (q *Queries) GetAudioByLiveKitTrack(ctx context.Context, livekitTrackSid *string) (AliciaAudio, error) {
	row := q.db.QueryRow(ctx, getAudioByLiveKitTrack, livekitTrackSid)
	var i AliciaAudio
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.AudioType,
		&i.AudioFormat,
		&i.AudioData,
		&i.DurationMs,
		&i.Transcription,
		&i.LivekitTrackSid,
		&i.TranscriptionMeta,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAudioByMessage = `-- name: GetAudioByMessage :one
SELECT id, message_id, audio_type, audio_format, audio_data, duration_ms, transcription, livekit_track_sid, transcription_meta, created_at, updated_at, deleted_at FROM alicia_audio
WHERE message_id = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetAudioByMessage(ctx context.Context, messageID *string) (AliciaAudio, error) {
	row := q.db.QueryRow(ctx, getAudioByMessage, messageID)
	var i AliciaAudio
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.AudioType,
		&i.AudioFormat,
		&i.AudioData,
		&i.DurationMs,
		&i.Transcription,
		&i.LivekitTrackSid,
		&i.TranscriptionMeta,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCommentariesByConversation = `-- name: GetCommentariesByConversation :many
SELECT id, content, conversation_id, message_id, created_by, meta, created_at, updated_at, deleted_at FROM alicia_user_conversation_commentaries
WHERE conversation_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetCommentariesByConversation(ctx context.Context, conversationID string) ([]AliciaUserConversationCommentary, error) {
	rows, err := q.db.Query(ctx, getCommentariesByConversation, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AliciaUserConversationCommentary{}
	for rows.Next() {
		var i AliciaUserConversationCommentary
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.ConversationID,
			&i.MessageID,
			&i.CreatedBy,
			&i.Meta,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentariesByMessage = `-- name: GetCommentariesByMessage :many
SELECT id, content, conversation_id, message_id, created_by, meta, created_at, updated_at, deleted_at FROM alicia_user_conversation_commentaries
WHERE message_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetCommentariesByMessage(ctx context.Context, messageID *string) ([]AliciaUserConversationCommentary, error) {
	rows, err := q.db.Query(ctx, getCommentariesByMessage, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AliciaUserConversationCommentary{}
	for rows.Next() {
		var i AliciaUserConversationCommentary
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.ConversationID,
			&i.MessageID,
			&i.CreatedBy,
			&i.Meta,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentaryByID = `-- name: GetCommentaryByID :one
SELECT id, content, conversation_id, message_id, created_by, meta, created_at, updated_at, deleted_at FROM alicia_user_conversation_commentaries
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetCommentaryByID(ctx context.Context, id string) (AliciaUserConversationCommentary, error) {
	row := q.db.QueryRow(ctx, getCommentaryByID, id)
	var i AliciaUserConversationCommentary
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.ConversationID,
		&i.MessageID,
		&i.CreatedBy,
		&i.Meta,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getConversationByID = `-- name: GetConversationByID :one
SELECT id, user_id, title, status, livekit_room_name, preferences, last_client_stanza_id, last_server_stanza_id, created_at, updated_at, deleted_at, tip_message_id, system_prompt_version_id FROM alicia_conversations
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetConversationByID(ctx context.Context, id string) (AliciaConversation, error) {
	row := q.db.QueryRow(ctx, getConversationByID, id)
	var i AliciaConversation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Status,
		&i.LivekitRoomName,
		&i.Preferences,
		&i.LastClientStanzaID,
		&i.LastServerStanzaID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TipMessageID,
		&i.SystemPromptVersionID,
	)
	return i, err
}

const getConversationByLiveKitRoom = `-- name: GetConversationByLiveKitRoom :one
SELECT id, user_id, title, status, livekit_room_name, preferences, last_client_stanza_id, last_server_stanza_id, created_at, updated_at, deleted_at, tip_message_id, system_prompt_version_id FROM alicia_conversations
WHERE livekit_room_name = $1 AND deleted_at IS NULL
`

func (q *Queries) GetConversationByLiveKitRoom(ctx context.Context, livekitRoomName *string) (AliciaConversation, error) {
	row := q.db.QueryRow(ctx, getConversationByLiveKitRoom, livekitRoomName)
	var i AliciaConversation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Status,
		&i.LivekitRoomName,
		&i.Preferences,
		&i.LastClientStanzaID,
		&i.LastServerStanzaID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TipMessageID,
		&i.SystemPromptVersionID,
	)
	return i, err
}

const getLatestMessagesByConversation = `-- name: GetLatestMessagesByConversation :many
SELECT id, conversation_id, sequence_number, previous_id, message_role, contents, local_id, server_id, sync_status, synced_at, completion_status, created_at, updated_at, deleted_at FROM alicia_messages
WHERE conversation_id = $1 AND deleted_at IS NULL
ORDER BY sequence_number DESC
LIMIT $2
`

type GetLatestMessagesByConversationParams struct {
	ConversationID string `json:"conversation_id"`
	Limit          int32  `json:"limit"`
}

func (q *Queries) GetLatestMessagesByConversation(ctx context.Context, arg GetLatestMessagesByConversationParams) ([]AliciaMessage, error) {
	rows, err := q.db.Query(ctx, getLatestMessagesByConversation, arg.ConversationID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AliciaMessage{}
	for rows.Next() {
		var i AliciaMessage
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SequenceNumber,
			&i.PreviousID,
			&i.MessageRole,
			&i.Contents,
			&i.LocalID,
			&i.ServerID,
			&i.SyncStatus,
			&i.SyncedAt,
			&i.CompletionStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemoriesByTags = `-- name: GetMemoriesByTags :many
SELECT id, content, embeddings, embeddings_info, importance, confidence, user_rating, created_by, source_type, source_info, tags, pinned, archived, created_at, updated_at, deleted_at, source_message_id FROM alicia_memory
WHERE deleted_at IS NULL AND tags && $1
ORDER BY importance DESC, created_at DESC
LIMIT $2
`

type GetMemoriesByTagsParams struct {
	Tags  []string `json:"tags"`
	Limit int32    `json:"limit"`
}

func (q *Queries) GetMemoriesByTags(ctx context.Context, arg GetMemoriesByTagsParams) ([]AliciaMemory, error) {
	rows, err := q.db.Query(ctx, getMemoriesByTags, arg.Tags, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AliciaMemory{}
	for rows.Next() {
		var i AliciaMemory
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.Embeddings,
			&i.EmbeddingsInfo,
			&i.Importance,
			&i.Confidence,
			&i.UserRating,
			&i.CreatedBy,
			&i.SourceType,
			&i.SourceInfo,
			&i.Tags,
			&i.Pinned,
			&i.Archived,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.SourceMessageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemoryByID = `-- name: GetMemoryByID :one
SELECT id, content, embeddings, embeddings_info, importance, confidence, user_rating, created_by, source_type, source_info, tags, pinned, archived, created_at, updated_at, deleted_at, source_message_id FROM alicia_memory
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetMemoryByID(ctx context.Context, id string) (AliciaMemory, error) {
	row := q.db.QueryRow(ctx, getMemoryByID, id)
	var i AliciaMemory
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.Embeddings,
		&i.EmbeddingsInfo,
		&i.Importance,
		&i.Confidence,
		&i.UserRating,
		&i.CreatedBy,
		&i.SourceType,
		&i.SourceInfo,
		&i.Tags,
		&i.Pinned,
		&i.Archived,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.SourceMessageID,
	)
	return i, err
}

const getMemoryUsageByConversation = `-- name: GetMemoryUsageByConversation :many
SELECT id, conversation_id, message_id, memory_id, query_prompt, query_prompt_meta, similarity_score, meta, position_in_results, created_at, updated_at, deleted_at FROM alicia_memory_used
WHERE conversation_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetMemoryUsageByConversation(ctx context.Context, conversationID string) ([]AliciaMemoryUsed, error) {
	rows, err := q.db.Query(ctx, getMemoryUsageByConversation, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AliciaMemoryUsed{}
	for rows.Next() {
		var i AliciaMemoryUsed
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.MessageID,
			&i.MemoryID,
			&i.QueryPrompt,
			&i.QueryPromptMeta,
			&i.SimilarityScore,
			&i.Meta,
			&i.PositionInResults,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemoryUsageByMemory = `-- name: GetMemoryUsageByMemory :many
SELECT id, conversation_id, message_id, memory_id, query_prompt, query_prompt_meta, similarity_score, meta, position_in_results, created_at, updated_at, deleted_at FROM alicia_memory_used
WHERE memory_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetMemoryUsageByMemory(ctx context.Context, memoryID string) ([]AliciaMemoryUsed, error) {
	rows, err := q.db.Query(ctx, getMemoryUsageByMemory, memoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AliciaMemoryUsed{}
	for rows.Next() {
		var i AliciaMemoryUsed
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.MessageID,
			&i.MemoryID,
			&i.QueryPrompt,
			&i.QueryPromptMeta,
			&i.SimilarityScore,
			&i.Meta,
			&i.PositionInResults,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemoryUsageByMessage = `-- name: GetMemoryUsageByMessage :many
SELECT id, conversation_id, message_id, memory_id, query_prompt, query_prompt_meta, similarity_score, meta, position_in_results, created_at, updated_at, deleted_at FROM alicia_memory_used
WHERE message_id = $1 AND deleted_at IS NULL
ORDER BY position_in_results ASC
`

func (q *Queries) GetMemoryUsageByMessage(ctx context.Context, messageID string) ([]AliciaMemoryUsed, error) {
	rows, err := q.db.Query(ctx, getMemoryUsageByMessage, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AliciaMemoryUsed{}
	for rows.Next() {
		var i AliciaMemoryUsed
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.MessageID,
			&i.MemoryID,
			&i.QueryPrompt,
			&i.QueryPromptMeta,
			&i.SimilarityScore,
			&i.Meta,
			&i.PositionInResults,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessageByID = `-- name: GetMessageByID :one
SELECT id, conversation_id, sequence_number, previous_id, message_role, contents, local_id, server_id, sync_status, synced_at, completion_status, created_at, updated_at, deleted_at FROM alicia_messages
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetMessageByID(ctx context.Context, id string) (AliciaMessage, error) {
	row := q.db.QueryRow(ctx, getMessageByID, id)
	var i AliciaMessage
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.SequenceNumber,
		&i.PreviousID,
		&i.MessageRole,
		&i.Contents,
		&i.LocalID,
		&i.ServerID,
		&i.SyncStatus,
		&i.SyncedAt,
		&i.CompletionStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getMessagesByConversation = `-- name: GetMessagesByConversation :many
SELECT id, conversation_id, sequence_number, previous_id, message_role, contents, local_id, server_id, sync_status, synced_at, completion_status, created_at, updated_at, deleted_at FROM alicia_messages
WHERE conversation_id = $1 AND deleted_at IS NULL
ORDER BY sequence_number ASC
`

func (q *Queries) GetMessagesByConversation(ctx context.Context, conversationID string) ([]AliciaMessage, error) {
	rows, err := q.db.Query(ctx, getMessagesByConversation, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AliciaMessage{}
	for rows.Next() {
		var i AliciaMessage
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SequenceNumber,
			&i.PreviousID,
			&i.MessageRole,
			&i.Contents,
			&i.LocalID,
			&i.ServerID,
			&i.SyncStatus,
			&i.SyncedAt,
			&i.CompletionStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMeta = `-- name: GetMeta :one
SELECT id, ref, key, value, created_at, updated_at, deleted_at FROM alicia_meta
WHERE ref = $1 AND key = $2 AND deleted_at IS NULL
`

type GetMetaParams struct {
	Ref string `json:"ref"`
	Key string `json:"key"`
}

func (q *Queries) GetMeta(ctx context.Context, arg GetMetaParams) (AliciaMetum, error) {
	row := q.db.QueryRow(ctx, getMeta, arg.Ref, arg.Key)
	var i AliciaMetum
	err := row.Scan(
		&i.ID,
		&i.Ref,
		&i.Key,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getNextMessageSequenceNumber = `-- name: GetNextMessageSequenceNumber :one
SELECT COALESCE(MAX(sequence_number), 0) + 1 as next_sequence
FROM alicia_messages
WHERE conversation_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetNextMessageSequenceNumber(ctx context.Context, conversationID string) (int32, error) {
	row := q.db.QueryRow(ctx, getNextMessageSequenceNumber, conversationID)
	var next_sequence int32
	err := row.Scan(&next_sequence)
	return next_sequence, err
}

const getNextReasoningStepSequenceNumber = `-- name: GetNextReasoningStepSequenceNumber :one
SELECT COALESCE(MAX(sequence_number), 0) + 1 as next_sequence
FROM alicia_reasoning_steps
WHERE message_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetNextReasoningStepSequenceNumber(ctx context.Context, messageID string) (int32, error) {
	row := q.db.QueryRow(ctx, getNextReasoningStepSequenceNumber, messageID)
	var next_sequence int32
	err := row.Scan(&next_sequence)
	return next_sequence, err
}

const getNextSentenceSequenceNumber = `-- name: GetNextSentenceSequenceNumber :one
SELECT COALESCE(MAX(sentence_sequence_number), 0) + 1 as next_sequence
FROM alicia_sentences
WHERE message_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetNextSentenceSequenceNumber(ctx context.Context, messageID string) (int32, error) {
	row := q.db.QueryRow(ctx, getNextSentenceSequenceNumber, messageID)
	var next_sequence int32
	err := row.Scan(&next_sequence)
	return next_sequence, err
}

const getPendingToolUses = `-- name: GetPendingToolUses :many
SELECT id, message_id, tool_name, tool_arguments, tool_result, status, error_message, sequence_number, completed_at, created_at, updated_at, deleted_at FROM alicia_tool_uses
WHERE status = 'pending' AND deleted_at IS NULL
ORDER BY created_at ASC
LIMIT $1
`

func (q *Queries) GetPendingToolUses(ctx context.Context, limit int32) ([]AliciaToolUse, error) {
	rows, err := q.db.Query(ctx, getPendingToolUses, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AliciaToolUse{}
	for rows.Next() {
		var i AliciaToolUse
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.ToolName,
			&i.ToolArguments,
			&i.ToolResult,
			&i.Status,
			&i.ErrorMessage,
			&i.SequenceNumber,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReasoningStepsByMessage = `-- name: GetReasoningStepsByMessage :many
SELECT id, message_id, content, sequence_number, created_at, updated_at, deleted_at FROM alicia_reasoning_steps
WHERE message_id = $1 AND deleted_at IS NULL
ORDER BY sequence_number ASC
`

func (q *Queries) GetReasoningStepsByMessage(ctx context.Context, messageID string) ([]AliciaReasoningStep, error) {
	rows, err := q.db.Query(ctx, getReasoningStepsByMessage, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AliciaReasoningStep{}
	for rows.Next() {
		var i AliciaReasoningStep
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.Content,
			&i.SequenceNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSentenceByID = `-- name: GetSentenceByID :one
SELECT id, message_id, sentence_sequence_number, text, audio_type, audio_format, duration_ms, audio_bytesize, audio_data, meta, completion_status, created_at, updated_at, deleted_at FROM alicia_sentences
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetSentenceByID(ctx context.Context, id string) (AliciaSentence, error) {
	row := q.db.QueryRow(ctx, getSentenceByID, id)
	var i AliciaSentence
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.SentenceSequenceNumber,
		&i.Text,
		&i.AudioType,
		&i.AudioFormat,
		&i.DurationMs,
		&i.AudioBytesize,
		&i.AudioData,
		&i.Meta,
		&i.CompletionStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getSentencesByMessage = `-- name: GetSentencesByMessage :many
SELECT id, message_id, sentence_sequence_number, text, audio_type, audio_format, duration_ms, audio_bytesize, audio_data, meta, completion_status, created_at, updated_at, deleted_at FROM alicia_sentences
WHERE message_id = $1 AND deleted_at IS NULL
ORDER BY sentence_sequence_number ASC
`

func (q *Queries) GetSentencesByMessage(ctx context.Context, messageID string) ([]AliciaSentence, error) {
	rows, err := q.db.Query(ctx, getSentencesByMessage, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AliciaSentence{}
	for rows.Next() {
		var i AliciaSentence
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.SentenceSequenceNumber,
			&i.Text,
			&i.AudioType,
			&i.AudioFormat,
			&i.DurationMs,
			&i.AudioBytesize,
			&i.AudioData,
			&i.Meta,
			&i.CompletionStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getToolByID = `-- name: GetToolByID :one
SELECT id, name, description, schema, enabled, created_at, updated_at, deleted_at FROM alicia_tools
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetToolByID(ctx context.Context, id string) (AliciaTool, error) {
	row := q.db.QueryRow(ctx, getToolByID, id)
	var i AliciaTool
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Schema,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getToolByName = `-- name: GetToolByName :one
SELECT id, name, description, schema, enabled, created_at, updated_at, deleted_at FROM alicia_tools
WHERE name = $1 AND deleted_at IS NULL
`

func (q *Queries) GetToolByName(ctx context.Context, name string) (AliciaTool, error) {
	row := q.db.QueryRow(ctx, getToolByName, name)
	var i AliciaTool
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Schema,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getToolUseByID = `-- name: GetToolUseByID :one
SELECT id, message_id, tool_name, tool_arguments, tool_result, status, error_message, sequence_number, completed_at, created_at, updated_at, deleted_at FROM alicia_tool_uses
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetToolUseByID(ctx context.Context, id string) (AliciaToolUse, error) {
	row := q.db.QueryRow(ctx, getToolUseByID, id)
	var i AliciaToolUse
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.ToolName,
		&i.ToolArguments,
		&i.ToolResult,
		&i.Status,
		&i.ErrorMessage,
		&i.SequenceNumber,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getToolUsesByMessage = `-- name: GetToolUsesByMessage :many
SELECT id, message_id, tool_name, tool_arguments, tool_result, status, error_message, sequence_number, completed_at, created_at, updated_at, deleted_at FROM alicia_tool_uses
WHERE message_id = $1 AND deleted_at IS NULL
ORDER BY sequence_number ASC
`

func (q *Queries) GetToolUsesByMessage(ctx context.Context, messageID string) ([]AliciaToolUse, error) {
	rows, err := q.db.Query(ctx, getToolUsesByMessage, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AliciaToolUse{}
	for rows.Next() {
		var i AliciaToolUse
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.ToolName,
			&i.ToolArguments,
			&i.ToolResult,
			&i.Status,
			&i.ErrorMessage,
			&i.SequenceNumber,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveConversations = `-- name: ListActiveConversations :many
SELECT id, user_id, title, status, livekit_room_name, preferences, last_client_stanza_id, last_server_stanza_id, created_at, updated_at, deleted_at, tip_message_id, system_prompt_version_id FROM alicia_conversations
WHERE status = 'active' AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListActiveConversationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListActiveConversations(ctx context.Context, arg ListActiveConversationsParams) ([]AliciaConversation, error) {
	rows, err := q.db.Query(ctx, listActiveConversations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AliciaConversation{}
	for rows.Next() {
		var i AliciaConversation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Status,
			&i.LivekitRoomName,
			&i.Preferences,
			&i.LastClientStanzaID,
			&i.LastServerStanzaID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TipMessageID,
			&i.SystemPromptVersionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllTools = `-- name: ListAllTools :many
SELECT id, name, description, schema, enabled, created_at, updated_at, deleted_at FROM alicia_tools
WHERE deleted_at IS NULL
ORDER BY name ASC
`

func (q *Queries) ListAllTools(ctx context.Context) ([]AliciaTool, error) {
	rows, err := q.db.Query(ctx, listAllTools)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AliciaTool{}
	for rows.Next() {
		var i AliciaTool
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Schema,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConversations = `-- name: ListConversations :many
SELECT id, user_id, title, status, livekit_room_name, preferences, last_client_stanza_id, last_server_stanza_id, created_at, updated_at, deleted_at, tip_message_id, system_prompt_version_id FROM alicia_conversations
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListConversationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListConversations(ctx context.Context, arg ListConversationsParams) ([]AliciaConversation, error) {
	rows, err := q.db.Query(ctx, listConversations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AliciaConversation{}
	for rows.Next() {
		var i AliciaConversation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Status,
			&i.LivekitRoomName,
			&i.Preferences,
			&i.LastClientStanzaID,
			&i.LastServerStanzaID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TipMessageID,
			&i.SystemPromptVersionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnabledTools = `-- name: ListEnabledTools :many
SELECT id, name, description, schema, enabled, created_at, updated_at, deleted_at FROM alicia_tools
WHERE enabled = true AND deleted_at IS NULL
ORDER BY name ASC
`

func (q *Queries) ListEnabledTools(ctx context.Context) ([]AliciaTool, error) {
	rows, err := q.db.Query(ctx, listEnabledTools)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AliciaTool{}
	for rows.Next() {
		var i AliciaTool
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Schema,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMemoryByEmbedding = `-- name: SearchMemoryByEmbedding :many
SELECT id, content, embeddings, embeddings_info, importance, confidence, user_rating, created_by, source_type, source_info, tags, pinned, archived, created_at, updated_at, deleted_at, source_message_id, 1 - (embeddings <=> $1) as similarity_score
FROM alicia_memory
WHERE deleted_at IS NULL AND embeddings IS NOT NULL
ORDER BY embeddings <=> $1
LIMIT $2
`

type SearchMemoryByEmbeddingParams struct {
	Embeddings *pgvector.Vector `json:"embeddings"`
	Limit      int32            `json:"limit"`
}

type SearchMemoryByEmbeddingRow struct {
	ID              string           `json:"id"`
	Content         string           `json:"content"`
	Embeddings      *pgvector.Vector `json:"embeddings"`
	EmbeddingsInfo  []byte           `json:"embeddings_info"`
	Importance      *float32         `json:"importance"`
	Confidence      *float32         `json:"confidence"`
	UserRating      *int32           `json:"user_rating"`
	CreatedBy       *string          `json:"created_by"`
	SourceType      *string          `json:"source_type"`
	SourceInfo      []byte           `json:"source_info"`
	Tags            []string         `json:"tags"`
	Pinned          bool             `json:"pinned"`
	Archived        bool             `json:"archived"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
	DeletedAt       pgtype.Timestamp `json:"deleted_at"`
	SourceMessageID *string          `json:"source_message_id"`
	SimilarityScore int32            `json:"similarity_score"`
}

func (q *Queries) SearchMemoryByEmbedding(ctx context.Context, arg SearchMemoryByEmbeddingParams) ([]SearchMemoryByEmbeddingRow, error) {
	rows, err := q.db.Query(ctx, searchMemoryByEmbedding, arg.Embeddings, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchMemoryByEmbeddingRow{}
	for rows.Next() {
		var i SearchMemoryByEmbeddingRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.Embeddings,
			&i.EmbeddingsInfo,
			&i.Importance,
			&i.Confidence,
			&i.UserRating,
			&i.CreatedBy,
			&i.SourceType,
			&i.SourceInfo,
			&i.Tags,
			&i.Pinned,
			&i.Archived,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.SourceMessageID,
			&i.SimilarityScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMemoryByEmbeddingWithThreshold = `-- name: SearchMemoryByEmbeddingWithThreshold :many
SELECT id, content, embeddings, embeddings_info, importance, confidence, user_rating, created_by, source_type, source_info, tags, pinned, archived, created_at, updated_at, deleted_at, source_message_id, 1 - (embeddings <=> $1) as similarity_score
FROM alicia_memory
WHERE deleted_at IS NULL
  AND embeddings IS NOT NULL
  AND 1 - (embeddings <=> $1) >= $2
ORDER BY embeddings <=> $1
LIMIT $3
`

type SearchMemoryByEmbeddingWithThresholdParams struct {
	Embeddings   *pgvector.Vector `json:"embeddings"`
	Embeddings_2 *pgvector.Vector `json:"embeddings_2"`
	Limit        int32            `json:"limit"`
}

type SearchMemoryByEmbeddingWithThresholdRow struct {
	ID              string           `json:"id"`
	Content         string           `json:"content"`
	Embeddings      *pgvector.Vector `json:"embeddings"`
	EmbeddingsInfo  []byte           `json:"embeddings_info"`
	Importance      *float32         `json:"importance"`
	Confidence      *float32         `json:"confidence"`
	UserRating      *int32           `json:"user_rating"`
	CreatedBy       *string          `json:"created_by"`
	SourceType      *string          `json:"source_type"`
	SourceInfo      []byte           `json:"source_info"`
	Tags            []string         `json:"tags"`
	Pinned          bool             `json:"pinned"`
	Archived        bool             `json:"archived"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
	DeletedAt       pgtype.Timestamp `json:"deleted_at"`
	SourceMessageID *string          `json:"source_message_id"`
	SimilarityScore int32            `json:"similarity_score"`
}

func (q *Queries) SearchMemoryByEmbeddingWithThreshold(ctx context.Context, arg SearchMemoryByEmbeddingWithThresholdParams) ([]SearchMemoryByEmbeddingWithThresholdRow, error) {
	rows, err := q.db.Query(ctx, searchMemoryByEmbeddingWithThreshold, arg.Embeddings, arg.Embeddings_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchMemoryByEmbeddingWithThresholdRow{}
	for rows.Next() {
		var i SearchMemoryByEmbeddingWithThresholdRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.Embeddings,
			&i.EmbeddingsInfo,
			&i.Importance,
			&i.Confidence,
			&i.UserRating,
			&i.CreatedBy,
			&i.SourceType,
			&i.SourceInfo,
			&i.Tags,
			&i.Pinned,
			&i.Archived,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.SourceMessageID,
			&i.SimilarityScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAudio = `-- name: UpdateAudio :exec
UPDATE alicia_audio
SET message_id = $2,
    audio_data = $3,
    duration_ms = $4,
    transcription = $5,
    livekit_track_sid = $6,
    transcription_meta = $7,
    updated_at = $8
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateAudioParams struct {
	ID                string           `json:"id"`
	MessageID         *string          `json:"message_id"`
	AudioData         []byte           `json:"audio_data"`
	DurationMs        *int32           `json:"duration_ms"`
	Transcription     *string          `json:"transcription"`
	LivekitTrackSid   *string          `json:"livekit_track_sid"`
	TranscriptionMeta []byte           `json:"transcription_meta"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpdateAudio(ctx context.Context, arg UpdateAudioParams) error {
	_, err := q.db.Exec(ctx, updateAudio,
		arg.ID,
		arg.MessageID,
		arg.AudioData,
		arg.DurationMs,
		arg.Transcription,
		arg.LivekitTrackSid,
		arg.TranscriptionMeta,
		arg.UpdatedAt,
	)
	return err
}

const updateConversation = `-- name: UpdateConversation :exec
UPDATE alicia_conversations
SET title = $2,
    status = $3,
    livekit_room_name = $4,
    preferences = $5,
    updated_at = $6
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateConversationParams struct {
	ID              string             `json:"id"`
	Title           string             `json:"title"`
	Status          ConversationStatus `json:"status"`
	LivekitRoomName *string            `json:"livekit_room_name"`
	Preferences     []byte             `json:"preferences"`
	UpdatedAt       pgtype.Timestamp   `json:"updated_at"`
}

func (q *Queries) UpdateConversation(ctx context.Context, arg UpdateConversationParams) error {
	_, err := q.db.Exec(ctx, updateConversation,
		arg.ID,
		arg.Title,
		arg.Status,
		arg.LivekitRoomName,
		arg.Preferences,
		arg.UpdatedAt,
	)
	return err
}

const updateMemory = `-- name: UpdateMemory :exec
UPDATE alicia_memory
SET content = $2,
    embeddings = $3,
    embeddings_info = $4,
    importance = $5,
    confidence = $6,
    user_rating = $7,
    created_by = $8,
    source_type = $9,
    source_info = $10,
    tags = $11,
    updated_at = $12
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateMemoryParams struct {
	ID             string           `json:"id"`
	Content        string           `json:"content"`
	Embeddings     *pgvector.Vector `json:"embeddings"`
	EmbeddingsInfo []byte           `json:"embeddings_info"`
	Importance     *float32         `json:"importance"`
	Confidence     *float32         `json:"confidence"`
	UserRating     *int32           `json:"user_rating"`
	CreatedBy      *string          `json:"created_by"`
	SourceType     *string          `json:"source_type"`
	SourceInfo     []byte           `json:"source_info"`
	Tags           []string         `json:"tags"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpdateMemory(ctx context.Context, arg UpdateMemoryParams) error {
	_, err := q.db.Exec(ctx, updateMemory,
		arg.ID,
		arg.Content,
		arg.Embeddings,
		arg.EmbeddingsInfo,
		arg.Importance,
		arg.Confidence,
		arg.UserRating,
		arg.CreatedBy,
		arg.SourceType,
		arg.SourceInfo,
		arg.Tags,
		arg.UpdatedAt,
	)
	return err
}

const updateMessage = `-- name: UpdateMessage :exec
UPDATE alicia_messages
SET previous_id = $2,
    contents = $3,
    updated_at = $4
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateMessageParams struct {
	ID         string           `json:"id"`
	PreviousID *string          `json:"previous_id"`
	Contents   string           `json:"contents"`
	UpdatedAt  pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpdateMessage(ctx context.Context, arg UpdateMessageParams) error {
	_, err := q.db.Exec(ctx, updateMessage,
		arg.ID,
		arg.PreviousID,
		arg.Contents,
		arg.UpdatedAt,
	)
	return err
}

const updateSentence = `-- name: UpdateSentence :exec
UPDATE alicia_sentences
SET text = $2,
    audio_type = $3,
    audio_format = $4,
    duration_ms = $5,
    audio_bytesize = $6,
    audio_data = $7,
    meta = $8,
    updated_at = $9
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateSentenceParams struct {
	ID            string           `json:"id"`
	Text          string           `json:"text"`
	AudioType     NullAudioType    `json:"audio_type"`
	AudioFormat   *string          `json:"audio_format"`
	DurationMs    *int32           `json:"duration_ms"`
	AudioBytesize *int32           `json:"audio_bytesize"`
	AudioData     []byte           `json:"audio_data"`
	Meta          []byte           `json:"meta"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpdateSentence(ctx context.Context, arg UpdateSentenceParams) error {
	_, err := q.db.Exec(ctx, updateSentence,
		arg.ID,
		arg.Text,
		arg.AudioType,
		arg.AudioFormat,
		arg.DurationMs,
		arg.AudioBytesize,
		arg.AudioData,
		arg.Meta,
		arg.UpdatedAt,
	)
	return err
}

const updateTool = `-- name: UpdateTool :exec
UPDATE alicia_tools
SET name = $2,
    description = $3,
    schema = $4,
    enabled = $5,
    updated_at = $6
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateToolParams struct {
	ID          string           `json:"id"`
	Name        string           `json:"name"`
	Description string           `json:"description"`
	Schema      json.RawMessage  `json:"schema"`
	Enabled     bool             `json:"enabled"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpdateTool(ctx context.Context, arg UpdateToolParams) error {
	_, err := q.db.Exec(ctx, updateTool,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Schema,
		arg.Enabled,
		arg.UpdatedAt,
	)
	return err
}

const updateToolUse = `-- name: UpdateToolUse :exec
UPDATE alicia_tool_uses
SET tool_result = $2,
    status = $3,
    error_message = $4,
    completed_at = $5,
    updated_at = $6
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateToolUseParams struct {
	ID           string           `json:"id"`
	ToolResult   []byte           `json:"tool_result"`
	Status       ToolStatus       `json:"status"`
	ErrorMessage *string          `json:"error_message"`
	CompletedAt  pgtype.Timestamp `json:"completed_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpdateToolUse(ctx context.Context, arg UpdateToolUseParams) error {
	_, err := q.db.Exec(ctx, updateToolUse,
		arg.ID,
		arg.ToolResult,
		arg.Status,
		arg.ErrorMessage,
		arg.CompletedAt,
		arg.UpdatedAt,
	)
	return err
}

const upsertMeta = `-- name: UpsertMeta :one

INSERT INTO alicia_meta (
    id, ref, key, value, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6
)
ON CONFLICT (ref, key) WHERE deleted_at IS NULL
DO UPDATE SET
    value = EXCLUDED.value,
    updated_at = EXCLUDED.updated_at
RETURNING id, ref, key, value, created_at, updated_at, deleted_at
`

type UpsertMetaParams struct {
	ID        string           `json:"id"`
	Ref       string           `json:"ref"`
	Key       string           `json:"key"`
	Value     *string          `json:"value"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

// ==============================================================================
// Meta
// ==============================================================================
func (q *Queries) UpsertMeta(ctx context.Context, arg UpsertMetaParams) (AliciaMetum, error) {
	row := q.db.QueryRow(ctx, upsertMeta,
		arg.ID,
		arg.Ref,
		arg.Key,
		arg.Value,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i AliciaMetum
	err := row.Scan(
		&i.ID,
		&i.Ref,
		&i.Key,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
