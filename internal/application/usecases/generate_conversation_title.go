package usecases

import (
	"context"
	"fmt"
	"log"
	"regexp"
	"strings"
	"time"

	"github.com/longregen/alicia/internal/ports"
)

// GenerateConversationTitle handles automatic title generation for conversations
type GenerateConversationTitle struct {
	conversationRepo ports.ConversationRepository
	messageRepo      ports.MessageRepository
	llmService       ports.LLMService
	broadcaster      ports.ConversationBroadcaster
}

// NewGenerateConversationTitle creates a new GenerateConversationTitle use case
func NewGenerateConversationTitle(
	conversationRepo ports.ConversationRepository,
	messageRepo ports.MessageRepository,
	llmService ports.LLMService,
	broadcaster ports.ConversationBroadcaster,
) *GenerateConversationTitle {
	return &GenerateConversationTitle{
		conversationRepo: conversationRepo,
		messageRepo:      messageRepo,
		llmService:       llmService,
		broadcaster:      broadcaster,
	}
}

// autoGeneratedTitlePattern matches titles like "Conversation 2024-01-15 14:30"
var autoGeneratedTitlePattern = regexp.MustCompile(`^Conversation \d{4}-\d{2}-\d{2} \d{2}:\d{2}$`)

// NeedsTitleGeneration checks if a conversation needs an auto-generated title
func (uc *GenerateConversationTitle) NeedsTitleGeneration(title string) bool {
	if title == "" {
		return true
	}
	return autoGeneratedTitlePattern.MatchString(title)
}

// Execute generates a title for a conversation if needed
// It checks if the title is auto-generated and replaces it with an LLM-generated one
func (uc *GenerateConversationTitle) Execute(ctx context.Context, conversationID string) error {
	// Get the conversation
	conversation, err := uc.conversationRepo.GetByID(ctx, conversationID)
	if err != nil {
		return fmt.Errorf("failed to get conversation: %w", err)
	}

	// Check if title generation is needed
	if !uc.NeedsTitleGeneration(conversation.Title) {
		return nil // Title already set, nothing to do
	}

	// Get the first few messages to understand the conversation topic
	messages, err := uc.messageRepo.GetLatestByConversation(ctx, conversationID, 5)
	if err != nil {
		return fmt.Errorf("failed to get messages: %w", err)
	}

	// Need at least one user message and one assistant message
	if len(messages) < 2 {
		return nil // Not enough context yet
	}

	// Build context from messages
	var messageContext strings.Builder
	for _, msg := range messages {
		role := string(msg.Role)
		// Truncate long messages
		content := msg.Contents
		if len(content) > 200 {
			content = content[:200] + "..."
		}
		messageContext.WriteString(fmt.Sprintf("%s: %s\n", role, content))
	}

	// Generate title using LLM
	title, err := uc.generateTitle(ctx, messageContext.String())
	if err != nil {
		return fmt.Errorf("failed to generate title: %w", err)
	}

	// Update conversation with new title
	conversation.Title = title
	conversation.UpdatedAt = time.Now().UTC()

	if err := uc.conversationRepo.Update(ctx, conversation); err != nil {
		return fmt.Errorf("failed to update conversation title: %w", err)
	}

	// Broadcast the title update to connected clients
	if uc.broadcaster != nil {
		uc.broadcaster.BroadcastConversationUpdate(conversation)
	}

	log.Printf("info: generated title for conversation %s: %s\n", conversationID, title)
	return nil
}

// generateTitle asks the LLM to create a concise title
func (uc *GenerateConversationTitle) generateTitle(ctx context.Context, messageContext string) (string, error) {
	prompt := []ports.LLMMessage{
		{
			Role: "system",
			Content: `You are a helpful assistant that generates concise conversation titles.
Given a conversation excerpt, generate a short, descriptive title that captures the main topic.

Rules:
- Maximum 50 characters
- Be concise and descriptive
- Use title case
- No quotes or special formatting
- Focus on the main topic or question
- If it's a greeting or casual chat, use something like "Casual Chat" or "Getting Started"

Examples:
- "Python List Sorting Help"
- "Recipe for Chocolate Cake"
- "Debugging React App"
- "Travel Plans for Paris"
- "Meeting Notes Summary"`,
		},
		{
			Role:    "user",
			Content: fmt.Sprintf("Generate a title for this conversation:\n\n%s", messageContext),
		},
	}

	response, err := uc.llmService.Chat(ctx, prompt)
	if err != nil {
		return "", fmt.Errorf("LLM chat failed: %w", err)
	}

	title := strings.TrimSpace(response.Content)

	// Clean up the title
	title = strings.Trim(title, `"'`)
	title = strings.TrimSpace(title)

	// Enforce max length
	if len(title) > 50 {
		// Try to cut at a word boundary
		if idx := strings.LastIndex(title[:47], " "); idx > 20 {
			title = title[:idx] + "..."
		} else {
			title = title[:47] + "..."
		}
	}

	// Fallback if title is empty or too short
	if len(title) < 3 {
		title = "New Conversation"
	}

	return title, nil
}

// ExecuteAsync runs title generation in a background goroutine
// This is the recommended way to call this use case after generating a response
func (uc *GenerateConversationTitle) ExecuteAsync(ctx context.Context, conversationID string) {
	go func() {
		// Use a detached context with timeout to avoid being cancelled when parent completes
		asyncCtx, cancel := context.WithTimeout(context.WithoutCancel(ctx), 30*time.Second)
		defer cancel()

		if err := uc.Execute(asyncCtx, conversationID); err != nil {
			log.Printf("warning: failed to generate conversation title: %v\n", err)
		}
	}()
}
